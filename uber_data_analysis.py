# -*- coding: utf-8 -*-
"""Uber_data_analysis.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ck3FmdIwXDBeft1Pj_5MdwDkp2q2vpVg
"""

#Name : Afsana Ansari

#Python project

#informative part:
#1. types of cabs --> Auto rickshaw, Prime, Mini, Luxury, Business,etc 
#2. 3-4 wheeler 
#3. Pricing  --> Base fares according to vehicle type
#4. Distance --> Depends on the type of vehicle
#5. Services --> Entertainment and meals ,etc
#6. Ratings  --> Cleanliness ratings, driver behaviour ratings, comfort ratings 

#Algo for oops-inheritance concept:
#1. Creating a main class that is cabs which contains the type of vehicle, vehicle name, minimum and maximum distance the vehicle can travel.
#2. Creating a child class names Services which will inherit the cabs attributes so that depending on the type of vehicles types of services can be shown.
#3. Another class of Ratings is created which will return the overall rating as the average of all the three ratings 
#   i.e. cleanliness rating, driver behaviour ratings, comfort ratings.

#Creating objects according to the type of vehicle and then passing the parameters.
#Inheritance should be involved with cabs and services class.

#Cabs class variables:
#1. Type of vehicle
#2. Vehicle name
#3. Maximum distance
#4. Minimum distance

#Cabs class methods:
#1. description : it will print the vehicle names and types of vehicle
#2. distance : will print the maximum distance and minimum distance that vehicle can travel.


class cabs:
    def __init__(self,type_vehicle,vehicle_name,max_dist,min_dist):
        self.type_vehicle = type_vehicle
        self.vehicle_name = vehicle_name
        self.max_dist = max_dist
        self.min_dist = min_dist
    
    def description(self,type_vehicle,vehicle_name):
        print("Vehicle type: ",self.type_vehicle)
        print("Vehicle name: ",self.vehicle_name)
        
    def distance(self,max_dist,min_dist):
        print("Maximum distance: ",self.max_dist)
        print("Minimum distance: ",self.min_dist)
        
    def pricing(self,vehicle_name,base_fare,price):
        if self.vehicle_name == "Auto Rickshaw":
          self.base_fare = "10 INR/km"
        elif self.vehicle_name == "Prime":
          self.base_fare = "13 INR/km"
        elif self.vehicle_name == "Mini":
          self.base_fare = "15 INR/km"
        elif self.vehicle_name == "Business":
          self.base_fare = "50 INR/km"
        elif self.vehicle_name == "Luxury":
          self.base_fare = "59 INR/km"
        else:
          self.base_fare = "0 INR/km"
        return self.base_fare

#Ratings class variables:
#1. Cleanliness ratings
#2. Driver ratings 
#3. Comfort ratings

#Ratings class methods:
#1. overall rating : this will give the average of all the ratings as the average of the ratings provided

class Ratings:
    def __init__(self,clean_rating,driver_rating,comfort_rating):
        self.clean_rating = clean_rating
        self.driver_rating = driver_rating
        self.comfort_rating = comfort_rating
    
    def overall_rating(self,clean_rating,driver_rating,comfort_rating):
        return round((self.clean_rating+self.driver_rating+self.comfort_rating)/3,2)

    
#Services class variables:
#1. Vehicle name is inherited by the Cabs class
#2. Entertainment : If available
#3. Meals : If available

#Services class methods:
#1. Entertainment: will give the entertainment type available according to the vehicle type
#2. Meals : Will give a menu about what meals can be availed in a particular journey according to journey distance

#Objects will be according to cab types

class Services(cabs):
    def __init__(self,entertainment,meals,type_vehicle=None,vehicle_name=None,max_dist=None,min_dist=None):
        self.entertainment = entertainment
        self.meals = meals
        cabs.__init__(self,type_vehicle,vehicle_name,max_dist,min_dist)
    
    def servce(self,vehicle_name,entertainment,meals):
        if self.vehicle_name == "Auto Rickshaw":
           self.entertainment = "NONE"
           self.meals = "Unavailable"
        elif self.vehicle_name == "Prime":
           self.entertainment = "TV, Music"
           self.meals = "Snacks"
        elif self.vehicle_name == "Mini":
           self.entertainment = "Music"
        elif self.vehicle_name == "Luxury":
           self.entertainment = "TV, Music,etc"
        elif self.vehicle_name == "Business":
           self.entertainment = "TV, Music,etc"
       
        return self.entertainment


cab1 = cabs("3 Wheeler","Auto Rickshaw","50 kms","1 km")
cab1.description("3 Wheeler","Auto Rickshaw")
cab1.distance("50 kms","1 km")
rating1 = Ratings(3,3,3)
print("Overall rating is",rating1.overall_rating(3,3,3))
print("Pricing : ",cab1.pricing("Auto Rickshaw","0","none"))
service1 = Services("","","","Auto Rickshaw","","")
print("Services provided : ",service1.servce("Auto Rickshaw","",""))
print("")

cab2 = cabs("4 Wheeler","Mini","100 kms","1 km")
cab2.description("4 Wheeler","Mini")
cab2.distance("100 kms","1 km")
rating2 = Ratings(3,4,5)
print("Overall rating is",rating2.overall_rating(3,4,5))
print("Pricing : ",cab1.pricing("Mini","0","none"))
service2 = Services("","","","Mini","","")
print("Services provided : ",service2.servce("Mini","",""))
print("")

cab3 = cabs("4 Wheeler","Prime","200 kms","1 km")
cab3.description("4 Wheeler","Prime")
cab3.distance("200 kms","1 km")
rating3 = Ratings(3,2,2)
print("Overall rating is",rating3.overall_rating(3,2,2))
print("Pricing : ",cab3.pricing("Prime","0","none"))
service3 = Services("","","","Prime","","")
print("Services provided : ",service3.servce("Prime","",""))
print("")

cab4 = cabs("4 Wheeler","Business","500 kms","1 km")
cab4.description("4 Wheeler","Business")
cab4.distance("500 kms","1 km")
rating4 = Ratings(4,4,5)
print("Overall rating is",rating4.overall_rating(4,4,5))
print("Pricing : ",cab4.pricing("Business","0","none"))
service4 = Services("","","","Business","","")
print("Services provided : ",service4.servce("Business","",""))
print("")

cab5 = cabs("4 Wheeler","Luxury","1000 kms","1 km")
cab5.description("4 Wheeler","Luxury")
cab5.distance("1000 kms","1 km")
rating5 = Ratings(3,5,5)
print("Overall rating is",rating5.overall_rating(3,5,5))
print("Pricing : ",cab5.pricing("Luxury","0","none"))
service5 = Services("","","","Luxury","","")
print("Services provided : ",service5.servce("Luxury","",""))
print("")

# Commented out IPython magic to ensure Python compatibility.
"# Analysis and Mathematical  Libraries"
import numpy as np

import pandas as pd

# Visualizations Libraries

import matplotlib.pyplot as plt
# %matplotlib inline

import seaborn as sns

# DateTime Libraries
import time, datetime

# Escape Warnings
import warnings
warnings.filterwarnings('ignore')

# Read the data of UBER 
# Here file is CSV i.e Comma Seperated Values
#df is a variable
#encoding = 'latin1'Fixing encoding errors in Pandas
#In fact, Pandas assumes that text is in UTF-8 format, because it is so common.
#In this case, as the filename suggests, the bytes for the text are in Latin 1 encoding.
#We can tell Pandas about this with the encoding= option: 
 
df = pd.read_csv(r"/content/My_Uber_Drives_-_2016.csv",encoding='latin1')
df.head(4) #to see if the data has been taken properly or not from the top

df.columns = df.columns.str.replace("*","") #to replace the "*" with a blank space to avoid unnecessary characters in our column names

df.tail(1) #to show the data from the last

df.info() #shows the data type of the column names present in the data set

df.shape #shows the number of rows and columns present in the data set

print("There are {} rows and {} columns are present in the Data Set".format(df.shape[0],df.shape[1]))

df.describe() #Calculates the count,  mean, standard deviation, minimum value, 1st Quartile, 2nd Quartile, 3rd Quartile and the maximum value

df.isnull().sum() #Shows the count of missing values in the data set

#visualizing the null values for each attribute
plt.figure(figsize=(10,5))   #defines the size of the box in which graph will be plotted
sns.heatmap(df.isnull(),cmap='magma',yticklabels=False,cbar=False) #when the missing value is seen then a colored strip is printed in the graph
plt.show()  #to show the graph

#visualizing the null values for each attribute

import missingno as msno

msno.bar(df)  #to show the count of data present without missing data
plt.show()    #shows the graph

null_columns=df.columns[df.isnull().any()]  #Shows the attributes such that where missing values are present 
df[null_columns].isnull().sum() #shows the count of the missing values

df.drop(index = 1155, axis = 0, inplace = True)  #deletes the row which was having missing values where the count is low

df.isnull().sum() #Shows the count of the missing values per attributes after deleting the missing value data

df["PURPOSE"].isnull().sum()/len(df)  #calculating the percentage of PURPOSE missing data

# filling a null values using fillna()
#ffill means forwadrd fill   (  non-null values forward)
df["PURPOSE"].fillna(method='ffill', inplace = True)  #forward fill fills the missing value with the upper value

df.isnull().sum() #to check if any other missing value is there in the data set or not

df['START_DATE']= pd.to_datetime(df['START_DATE'],errors='coerce') #to change the start date data type to datetime type
df['END_DATE']= pd.to_datetime(df['END_DATE'],errors='coerce')  #to change the stop date data type to datetime type
df.info(); #to confirm the changes made in the data type
# Now time object type changes to datetime

#to visualize the overall modified data
import missingno as msno
msno.bar(df)
plt.show()

#to count the travels as per category and visualize it using graph
#plt.legend()
Category =pd.crosstab(index=df['CATEGORY'],columns='Count of travels as per category')

Category.plot(kind='bar',color='r',alpha=0.7) #description of the graph which is needed 
plt.legend()
Category

#To count the startpoint frequency of each location > 10
Start_point = df.START.value_counts()
Start_point
print(Start_point[Start_point > 10])


Start_point[Start_point > 10].plot(kind = "pie", shadow=True, startangle=190)
plt.tight_layout()
plt.show()

#To see the startpoints count of each location <= 10
Start_point = df.START.value_counts()
Start_point
Start_point[Start_point <=  10]

#to print the count of stop points of each location > 10
Stop_point = df.STOP.value_counts()
Stop_point
Stop_point[Stop_point >=  10]

#to see the stop point count of each location <= 10
Stop_point = df.STOP.value_counts()
Stop_point
Stop_point[Stop_point <=  10]

#to print each count of the miles data and print it as a discrete data table
Miles = df.MILES.value_counts()
Miles
print(Miles[Miles> 10])


Miles[Miles> 10].plot(kind = "bar") #to show the graph of frequency having > 10
plt.tight_layout()
plt.show()

#to show the frequency of count of miles which are > 10 and <= 10 
Miles =pd.crosstab(index=df["MILES"]>10,columns='Count of Miles')

Miles.plot(kind='bar',color='r',alpha=0.7)
plt.legend()
Miles

print(df.PURPOSE.value_counts())  #to show the count of each purpose categorical values

#to show the frequency wise distribution according to the purpose of cabride
plt.figure(figsize=(15,6))
sns.countplot(df['PURPOSE'], order=df['PURPOSE'].value_counts().index, palette='viridis')
plt.show()

# For future Analysis

# Lets calculate the duration, as there might be some relation of it to PURPOSE of Cab ride.
df['MINUTES'] = df.END_DATE - df.START_DATE
df.head(3)

# As Duration is in datetime format, we need to convert it to float type in order to use it for analysis.
df['MINUTES'] = df['MINUTES'].dt.total_seconds() /60
df.head()

pd.DataFrame({'MEAN': df.groupby(['PURPOSE'])['MILES'].mean().round(1), 
              'MIN' : df.groupby(['PURPOSE'])['MILES'].min(), 
              'MAX' : df.groupby(["PURPOSE"])['MILES'].max()}).reset_index()

#Box plot of the purpose vs miles and purpose vs minutes graph for visualizing and understanding data more clearly
plt.figure(figsize=(16,7))
plt.subplot(1,2,1)
sns.boxplot(data=df, x=df.PURPOSE, y=df.MILES)
plt.xticks(rotation=45)
plt.subplot(1,2,2)
sns.boxplot(data=df, x=df.PURPOSE, y=df.MINUTES)
plt.xticks(rotation=45);

#Omitting the outliers from the previous graph 
plt.figure(figsize=(16,7))
plt.subplot(1,2,1)
sns.boxplot(data=df, x=df.PURPOSE, y=df.MILES,showfliers=False)
plt.xticks(rotation=45)
plt.subplot(1,2,2)
sns.boxplot(data=df, x=df.PURPOSE, y=df.MINUTES,showfliers=False)
plt.xticks(rotation=45);

#to see the number of round trips and one way trips
plt.figure(figsize=(8,5))
def round(x):
    if x['START'] == x['STOP']:
        return 'YES'
    else:
        return 'NO'
    
df['ROUND_TRIP'] = df.apply(round, axis=1)

sns.countplot(df['ROUND_TRIP'], order=df['ROUND_TRIP'].value_counts().index, palette='rocket_r')
plt.show()

df['MONTH'] = pd.DatetimeIndex(df['START_DATE']).month

dic = {1:'Jan', 2: 'Feb', 3: 'Mar', 4: 'April', 5: 'May', 6: 'June', 7: 'July', 8: 'Aug', 9: 'Sep',
      10: 'Oct', 11: 'Nov', 12: 'Dec' } #creating a dictionary for using it in plotting graphs

df['MONTH'] = df['MONTH'].map(dic)



# MAP FUNCTION : Its a build in function
# 1. This function is used to apply a function to all the elements of a sequence(list,tuple.strings)

#To visualizing the data according to the month and finding the mean trips accross the months
plt.figure(figsize=(12,7))
sns.countplot(df['MONTH'], order=df['MONTH'].value_counts().index, palette='deep')
plt.axhline(df['MONTH'].value_counts().mean(),linestyle='--', color = 'darkred', label='Mean Trips across Months')
plt.legend()
plt.show()

#To plot a graph of round trips and one way trips according to the month
plt.figure(figsize=(12,7))
a=sns.countplot(df['ROUND_TRIP'],hue=df['MONTH'])
plt.legend(bbox_to_anchor=(1.05, 0.95), loc=2)
plt.show()

#Plots of MILES with respect to MINUTES
plt.figure(figsize = (14,5))
plt.subplot(1,2,1)
sns.lineplot(data=df, x=df.MINUTES, y=df.MILES)
plt.grid(True, linestyle = "--")
plt.subplot(1,2,2)
sns.scatterplot(data=df, x=df.MINUTES, y=df.MILES)
plt.grid(True, linestyle = "--")

# cab rides took more time for less distance.

plt.figure(figsize = (16,5))

plt.subplot(1,2,1)
n, bins, patches = plt.hist(df.MINUTES)
plt.xticks(bins.round())
plt.grid(True, linestyle = "dotted")
plt.title("Count of Cab ride MINUTES")

plt.subplot(1,2,2)
n, bins, patches = plt.hist(df.MILES)
plt.xticks(bins.round())
plt.grid(True, linestyle = "dotted")
plt.title("Count of Cab ride MILES");

#to plot graph of purpose vs category in business and personal categories
plt.figure(figsize = (9,5))
sns.countplot(data=df,x="PURPOSE", hue = 'CATEGORY', dodge = False)
plt.xticks(rotation = 45);

#to plot the start location frequency of the dataset
plt.figure(figsize = (15,4))
pd.Series(df['START']).value_counts()[:25].plot(kind="bar")
plt.title("Cab Rides START Location frequency")
plt.xticks(rotation = 45);

#to plot the stop location frequency of the data
plt.figure(figsize=(15,4))
pd.Series(df['STOP']).value_counts()[:25].plot(kind = "bar")
plt.title("Cab Rides STOP Location frequency")
plt.xticks(rotation = 45);

g = sns.factorplot(x="PURPOSE", y="MILES", hue="CATEGORY", data=df,
                   size=15, kind="bar", palette="muted")
#from the graph is clearly seen that the main contributors for miles are:
#in Business category: meetings and customer; private: commute and charity 
g.fig.suptitle('Miles was earned per category and purpose', fontsize= 25)
g.fig.set_size_inches(15, 5)
g.set_xlabels('PURPOSE', fontsize= 20)
g.set_ylabels('MILES', fontsize= 20)

"""# Conclusion

> - Most of the cab rides are within a distance of 31 miles taking about 34 minutes.
> - Business Cab rides are not only more in volume, but also in distance travelled.
> - Main uses of cab rides are Meal/Entertainment, Customer visit, Meeting, Errand/Supplies.
> - Cab traffic is mostly concentrated in 5 cities or localities.
> - seasonal pattern of cab ride volume exists, which is highest on December.
"""

